{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Himaani/WebstormProjects/BibliaLMS/node_modules/%40upstash/qstash/chunk-H3E2J2K6.mjs"],"sourcesContent":["// src/receiver.ts\nimport * as jose from \"jose\";\nimport crypto2 from \"crypto-js\";\nvar SignatureError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SignatureError\";\n  }\n};\nvar Receiver = class {\n  currentSigningKey;\n  nextSigningKey;\n  constructor(config) {\n    this.currentSigningKey = config.currentSigningKey;\n    this.nextSigningKey = config.nextSigningKey;\n  }\n  /**\n   * Verify the signature of a request.\n   *\n   * Tries to verify the signature with the current signing key.\n   * If that fails, maybe because you have rotated the keys recently, it will\n   * try to verify the signature with the next signing key.\n   *\n   * If that fails, the signature is invalid and a `SignatureError` is thrown.\n   */\n  async verify(request) {\n    let payload;\n    try {\n      payload = await this.verifyWithKey(this.currentSigningKey, request);\n    } catch {\n      payload = await this.verifyWithKey(this.nextSigningKey, request);\n    }\n    this.verifyBodyAndUrl(payload, request);\n    return true;\n  }\n  /**\n   * Verify signature with a specific signing key\n   */\n  async verifyWithKey(key, request) {\n    const jwt = await jose.jwtVerify(request.signature, new TextEncoder().encode(key), {\n      issuer: \"Upstash\",\n      clockTolerance: request.clockTolerance\n    }).catch((error) => {\n      throw new SignatureError(error.message);\n    });\n    return jwt.payload;\n  }\n  verifyBodyAndUrl(payload, request) {\n    const p = payload;\n    if (request.url !== void 0 && p.sub !== request.url) {\n      throw new SignatureError(`invalid subject: ${p.sub}, want: ${request.url}`);\n    }\n    const bodyHash = crypto2.SHA256(request.body).toString(crypto2.enc.Base64url);\n    const padding = new RegExp(/=+$/);\n    if (p.body.replace(padding, \"\") !== bodyHash.replace(padding, \"\")) {\n      throw new SignatureError(`body hash does not match, want: ${p.body}, got: ${bodyHash}`);\n    }\n  }\n};\n\n// src/client/dlq.ts\nvar DLQ = class {\n  http;\n  constructor(http) {\n    this.http = http;\n  }\n  /**\n   * List messages in the dlq\n   */\n  async listMessages(options) {\n    const filterPayload = {\n      ...options?.filter,\n      topicName: options?.filter?.urlGroup\n    };\n    const messagesPayload = await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"dlq\"],\n      query: {\n        cursor: options?.cursor,\n        count: options?.count,\n        ...filterPayload\n      }\n    });\n    return {\n      messages: messagesPayload.messages.map((message) => {\n        return {\n          ...message,\n          urlGroup: message.topicName,\n          ratePerSecond: \"rate\" in message ? message.rate : void 0\n        };\n      }),\n      cursor: messagesPayload.cursor\n    };\n  }\n  /**\n   * Remove a message from the dlq using it's `dlqId`\n   */\n  async delete(dlqMessageId) {\n    return await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"dlq\", dlqMessageId],\n      parseResponseAsJson: false\n      // there is no response\n    });\n  }\n  /**\n   * Remove multiple messages from the dlq using their `dlqId`s\n   */\n  async deleteMany(request) {\n    return await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"dlq\"],\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ dlqIds: request.dlqIds })\n    });\n  }\n};\n\n// src/client/error.ts\nvar RATELIMIT_STATUS = 429;\nvar QstashError = class extends Error {\n  status;\n  constructor(message, status) {\n    super(message);\n    this.name = \"QstashError\";\n    this.status = status;\n  }\n};\nvar QstashRatelimitError = class extends QstashError {\n  limit;\n  remaining;\n  reset;\n  constructor(args) {\n    super(`Exceeded burst rate limit. ${JSON.stringify(args)}`, RATELIMIT_STATUS);\n    this.name = \"QstashRatelimitError\";\n    this.limit = args.limit;\n    this.remaining = args.remaining;\n    this.reset = args.reset;\n  }\n};\nvar QstashChatRatelimitError = class extends QstashError {\n  limitRequests;\n  limitTokens;\n  remainingRequests;\n  remainingTokens;\n  resetRequests;\n  resetTokens;\n  constructor(args) {\n    super(`Exceeded chat rate limit. ${JSON.stringify(args)}`, RATELIMIT_STATUS);\n    this.name = \"QstashChatRatelimitError\";\n    this.limitRequests = args[\"limit-requests\"];\n    this.limitTokens = args[\"limit-tokens\"];\n    this.remainingRequests = args[\"remaining-requests\"];\n    this.remainingTokens = args[\"remaining-tokens\"];\n    this.resetRequests = args[\"reset-requests\"];\n    this.resetTokens = args[\"reset-tokens\"];\n  }\n};\nvar QstashDailyRatelimitError = class extends QstashError {\n  limit;\n  remaining;\n  reset;\n  constructor(args) {\n    super(`Exceeded daily rate limit. ${JSON.stringify(args)}`, RATELIMIT_STATUS);\n    this.name = \"QstashDailyRatelimitError\";\n    this.limit = args.limit;\n    this.remaining = args.remaining;\n    this.reset = args.reset;\n  }\n};\nvar QStashWorkflowError = class extends QstashError {\n  constructor(message) {\n    super(message);\n    this.name = \"QStashWorkflowError\";\n  }\n};\nvar QStashWorkflowAbort = class extends Error {\n  stepInfo;\n  stepName;\n  constructor(stepName, stepInfo) {\n    super(\n      `This is an Upstash Workflow error thrown after a step executes. It is expected to be raised. Make sure that you await for each step. Also, if you are using try/catch blocks, you should not wrap context.run/sleep/sleepUntil/call methods with try/catch. Aborting workflow after executing step '${stepName}'.`\n    );\n    this.name = \"QStashWorkflowAbort\";\n    this.stepName = stepName;\n    this.stepInfo = stepInfo;\n  }\n};\nvar formatWorkflowError = (error) => {\n  return error instanceof Error ? {\n    error: error.name,\n    message: error.message\n  } : {\n    error: \"Error\",\n    message: \"An error occured while executing workflow.\"\n  };\n};\n\n// src/client/http.ts\nvar HttpClient = class {\n  baseUrl;\n  authorization;\n  options;\n  retry;\n  headers;\n  telemetryHeaders;\n  constructor(config) {\n    this.baseUrl = config.baseUrl.replace(/\\/$/, \"\");\n    this.authorization = config.authorization;\n    this.retry = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    typeof config.retry === \"boolean\" && !config.retry ? {\n      attempts: 1,\n      backoff: () => 0\n    } : {\n      attempts: config.retry?.retries ?? 5,\n      backoff: config.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50)\n    };\n    this.headers = config.headers;\n    this.telemetryHeaders = config.telemetryHeaders;\n  }\n  async request(request) {\n    const { response } = await this.requestWithBackoff(request);\n    if (request.parseResponseAsJson === false) {\n      return void 0;\n    }\n    return await response.json();\n  }\n  async *requestStream(request) {\n    const { response } = await this.requestWithBackoff(request);\n    if (!response.body) {\n      throw new Error(\"No response body\");\n    }\n    const body = response.body;\n    const reader = body.getReader();\n    const decoder = new TextDecoder();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n        const chunkText = decoder.decode(value, { stream: true });\n        const chunks = chunkText.split(\"\\n\").filter(Boolean);\n        for (const chunk of chunks) {\n          if (chunk.startsWith(\"data: \")) {\n            const data = chunk.slice(6);\n            if (data === \"[DONE]\") {\n              break;\n            }\n            yield JSON.parse(data);\n          }\n        }\n      }\n    } finally {\n      await reader.cancel();\n    }\n  }\n  requestWithBackoff = async (request) => {\n    const [url, requestOptions] = this.processRequest(request);\n    let response = void 0;\n    let error = void 0;\n    for (let index = 0; index <= this.retry.attempts; index++) {\n      try {\n        response = await fetch(url.toString(), requestOptions);\n        break;\n      } catch (error_) {\n        error = error_;\n        if (index < this.retry.attempts) {\n          await new Promise((r) => setTimeout(r, this.retry.backoff(index)));\n        }\n      }\n    }\n    if (!response) {\n      throw error ?? new Error(\"Exhausted all retries\");\n    }\n    await this.checkResponse(response);\n    return {\n      response,\n      error\n    };\n  };\n  processRequest = (request) => {\n    const headers = new Headers(request.headers);\n    if (!headers.has(\"Authorization\")) {\n      headers.set(\"Authorization\", this.authorization);\n    }\n    const requestOptions = {\n      method: request.method,\n      headers,\n      body: request.body,\n      keepalive: request.keepalive\n    };\n    const url = new URL([request.baseUrl ?? this.baseUrl, ...request.path].join(\"/\"));\n    if (request.query) {\n      for (const [key, value] of Object.entries(request.query)) {\n        if (value !== void 0) {\n          url.searchParams.set(key, value.toString());\n        }\n      }\n    }\n    return [url.toString(), requestOptions];\n  };\n  async checkResponse(response) {\n    if (response.status === 429) {\n      if (response.headers.get(\"x-ratelimit-limit-requests\")) {\n        throw new QstashChatRatelimitError({\n          \"limit-requests\": response.headers.get(\"x-ratelimit-limit-requests\"),\n          \"limit-tokens\": response.headers.get(\"x-ratelimit-limit-tokens\"),\n          \"remaining-requests\": response.headers.get(\"x-ratelimit-remaining-requests\"),\n          \"remaining-tokens\": response.headers.get(\"x-ratelimit-remaining-tokens\"),\n          \"reset-requests\": response.headers.get(\"x-ratelimit-reset-requests\"),\n          \"reset-tokens\": response.headers.get(\"x-ratelimit-reset-tokens\")\n        });\n      } else if (response.headers.get(\"RateLimit-Limit\")) {\n        throw new QstashDailyRatelimitError({\n          limit: response.headers.get(\"RateLimit-Limit\"),\n          remaining: response.headers.get(\"RateLimit-Remaining\"),\n          reset: response.headers.get(\"RateLimit-Reset\")\n        });\n      }\n      throw new QstashRatelimitError({\n        limit: response.headers.get(\"Burst-RateLimit-Limit\"),\n        remaining: response.headers.get(\"Burst-RateLimit-Remaining\"),\n        reset: response.headers.get(\"Burst-RateLimit-Reset\")\n      });\n    }\n    if (response.status < 200 || response.status >= 300) {\n      const body = await response.text();\n      throw new QstashError(\n        body.length > 0 ? body : `Error: status=${response.status}`,\n        response.status\n      );\n    }\n  }\n};\n\n// src/client/llm/providers.ts\nvar setupAnalytics = (analytics, providerApiKey, providerBaseUrl, provider) => {\n  if (!analytics)\n    return {};\n  switch (analytics.name) {\n    case \"helicone\": {\n      switch (provider) {\n        case \"upstash\": {\n          return {\n            baseURL: \"https://qstash.helicone.ai/llm/v1/chat/completions\",\n            defaultHeaders: {\n              \"Helicone-Auth\": `Bearer ${analytics.token}`,\n              Authorization: `Bearer ${providerApiKey}`\n            }\n          };\n        }\n        default: {\n          return {\n            baseURL: \"https://gateway.helicone.ai/v1/chat/completions\",\n            defaultHeaders: {\n              \"Helicone-Auth\": `Bearer ${analytics.token}`,\n              \"Helicone-Target-Url\": providerBaseUrl,\n              Authorization: `Bearer ${providerApiKey}`\n            }\n          };\n        }\n      }\n    }\n    default: {\n      throw new Error(\"Unknown analytics provider\");\n    }\n  }\n};\n\n// src/client/llm/chat.ts\nvar Chat = class _Chat {\n  http;\n  token;\n  constructor(http, token) {\n    this.http = http;\n    this.token = token;\n  }\n  static toChatRequest(request) {\n    const messages = [];\n    messages.push(\n      { role: \"system\", content: request.system },\n      { role: \"user\", content: request.user }\n    );\n    const chatRequest = { ...request, messages };\n    return chatRequest;\n  }\n  /**\n   * Calls the Upstash completions api given a ChatRequest.\n   *\n   * Returns a ChatCompletion or a stream of ChatCompletionChunks\n   * if stream is enabled.\n   *\n   * @param request ChatRequest with messages\n   * @returns Chat completion or stream\n   */\n  create = async (request) => {\n    if (request.provider.owner != \"upstash\")\n      return this.createThirdParty(request);\n    const body = JSON.stringify(request);\n    let baseUrl = void 0;\n    let headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.token}`,\n      ...\"stream\" in request && request.stream ? {\n        Connection: \"keep-alive\",\n        Accept: \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\"\n      } : {}\n    };\n    if (request.analytics) {\n      const { baseURL, defaultHeaders } = setupAnalytics(\n        { name: \"helicone\", token: request.analytics.token },\n        this.getAuthorizationToken(),\n        request.provider.baseUrl,\n        \"upstash\"\n      );\n      headers = { ...headers, ...defaultHeaders };\n      baseUrl = baseURL;\n    }\n    const path = request.analytics ? [] : [\"llm\", \"v1\", \"chat\", \"completions\"];\n    return \"stream\" in request && request.stream ? this.http.requestStream({\n      path,\n      method: \"POST\",\n      headers,\n      baseUrl,\n      body\n    }) : this.http.request({\n      path,\n      method: \"POST\",\n      headers,\n      baseUrl,\n      body\n    });\n  };\n  /**\n   * Calls the Upstash completions api given a ChatRequest.\n   *\n   * Returns a ChatCompletion or a stream of ChatCompletionChunks\n   * if stream is enabled.\n   *\n   * @param request ChatRequest with messages\n   * @returns Chat completion or stream\n   */\n  createThirdParty = async (request) => {\n    const { baseUrl, token, owner, organization } = request.provider;\n    if (owner === \"upstash\")\n      throw new Error(\"Upstash is not 3rd party provider!\");\n    delete request.provider;\n    delete request.system;\n    const analytics = request.analytics;\n    delete request.analytics;\n    const body = JSON.stringify(request);\n    const isAnalyticsEnabled = analytics?.name && analytics.token;\n    const analyticsConfig = analytics?.name && analytics.token ? setupAnalytics({ name: analytics.name, token: analytics.token }, token, baseUrl, owner) : { defaultHeaders: void 0, baseURL: baseUrl };\n    const isStream = \"stream\" in request && request.stream;\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${token}`,\n      ...organization ? {\n        \"OpenAI-Organization\": organization\n      } : {},\n      ...isStream ? {\n        Connection: \"keep-alive\",\n        Accept: \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\"\n      } : {},\n      ...analyticsConfig.defaultHeaders\n    };\n    const response = await this.http[isStream ? \"requestStream\" : \"request\"]({\n      path: isAnalyticsEnabled ? [] : [\"v1\", \"chat\", \"completions\"],\n      method: \"POST\",\n      headers,\n      body,\n      baseUrl: analyticsConfig.baseURL\n    });\n    return response;\n  };\n  // Helper method to get the authorization token\n  getAuthorizationToken() {\n    const authHeader = String(this.http.authorization);\n    const match = /Bearer (.+)/.exec(authHeader);\n    if (!match) {\n      throw new Error(\"Invalid authorization header format\");\n    }\n    return match[1];\n  }\n  /**\n   * Calls the Upstash completions api given a PromptRequest.\n   *\n   * Returns a ChatCompletion or a stream of ChatCompletionChunks\n   * if stream is enabled.\n   *\n   * @param request PromptRequest with system and user messages.\n   *    Note that system parameter shouldn't be passed in the case of\n   *    mistralai/Mistral-7B-Instruct-v0.2 model.\n   * @returns Chat completion or stream\n   */\n  prompt = async (request) => {\n    const chatRequest = _Chat.toChatRequest(request);\n    return this.create(chatRequest);\n  };\n};\n\n// src/client/messages.ts\nvar Messages = class {\n  http;\n  constructor(http) {\n    this.http = http;\n  }\n  /**\n   * Get a message\n   */\n  async get(messageId) {\n    const messagePayload = await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"messages\", messageId]\n    });\n    const message = {\n      ...messagePayload,\n      urlGroup: messagePayload.topicName,\n      ratePerSecond: \"rate\" in messagePayload ? messagePayload.rate : void 0\n    };\n    return message;\n  }\n  /**\n   * Cancel a message\n   */\n  async delete(messageId) {\n    return await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"messages\", messageId],\n      parseResponseAsJson: false\n    });\n  }\n  async deleteMany(messageIds) {\n    const result = await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"messages\"],\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ messageIds })\n    });\n    return result.cancelled;\n  }\n  async deleteAll() {\n    const result = await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"messages\"]\n    });\n    return result.cancelled;\n  }\n};\n\n// src/client/api/base.ts\nvar BaseProvider = class {\n  baseUrl;\n  token;\n  owner;\n  constructor(baseUrl, token, owner) {\n    this.baseUrl = baseUrl;\n    this.token = token;\n    this.owner = owner;\n  }\n  getUrl() {\n    return `${this.baseUrl}/${this.getRoute().join(\"/\")}`;\n  }\n};\n\n// src/client/api/llm.ts\nvar LLMProvider = class extends BaseProvider {\n  apiKind = \"llm\";\n  organization;\n  method = \"POST\";\n  constructor(baseUrl, token, owner, organization) {\n    super(baseUrl, token, owner);\n    this.organization = organization;\n  }\n  getRoute() {\n    return this.owner === \"anthropic\" ? [\"v1\", \"messages\"] : [\"v1\", \"chat\", \"completions\"];\n  }\n  getHeaders(options) {\n    if (this.owner === \"upstash\" && !options.analytics) {\n      return { \"content-type\": \"application/json\" };\n    }\n    const header = this.owner === \"anthropic\" ? \"x-api-key\" : \"authorization\";\n    const headerValue = this.owner === \"anthropic\" ? this.token : `Bearer ${this.token}`;\n    const headers = {\n      [header]: headerValue,\n      \"content-type\": \"application/json\"\n    };\n    if (this.owner === \"openai\" && this.organization) {\n      headers[\"OpenAI-Organization\"] = this.organization;\n    }\n    if (this.owner === \"anthropic\") {\n      headers[\"anthropic-version\"] = \"2023-06-01\";\n    }\n    return headers;\n  }\n  /**\n   * Checks if callback exists and adds analytics in place if it's set.\n   *\n   * @param request\n   * @param options\n   */\n  onFinish(providerInfo, options) {\n    if (options.analytics) {\n      return updateWithAnalytics(providerInfo, options.analytics);\n    }\n    return providerInfo;\n  }\n};\nvar upstash = () => {\n  return new LLMProvider(\"https://qstash.upstash.io/llm\", \"\", \"upstash\");\n};\nvar openai = ({\n  token,\n  organization\n}) => {\n  return new LLMProvider(\"https://api.openai.com\", token, \"openai\", organization);\n};\nvar anthropic = ({ token }) => {\n  return new LLMProvider(\"https://api.anthropic.com\", token, \"anthropic\");\n};\nvar custom = ({\n  baseUrl,\n  token\n}) => {\n  const trimmedBaseUrl = baseUrl.replace(/\\/(v1\\/)?chat\\/completions$/, \"\");\n  return new LLMProvider(trimmedBaseUrl, token, \"custom\");\n};\n\n// src/client/api/utils.ts\nvar getProviderInfo = (api, upstashToken) => {\n  const { name, provider, ...parameters } = api;\n  const finalProvider = provider ?? upstash();\n  if (finalProvider.owner === \"upstash\" && !finalProvider.token) {\n    finalProvider.token = upstashToken;\n  }\n  if (!finalProvider.baseUrl)\n    throw new TypeError(\"baseUrl cannot be empty or undefined!\");\n  if (!finalProvider.token)\n    throw new TypeError(\"token cannot be empty or undefined!\");\n  if (finalProvider.apiKind !== name) {\n    throw new TypeError(\n      `Unexpected api name. Expected '${finalProvider.apiKind}', received ${name}`\n    );\n  }\n  const providerInfo = {\n    url: finalProvider.getUrl(),\n    baseUrl: finalProvider.baseUrl,\n    route: finalProvider.getRoute(),\n    appendHeaders: finalProvider.getHeaders(parameters),\n    owner: finalProvider.owner,\n    method: finalProvider.method\n  };\n  return finalProvider.onFinish(providerInfo, parameters);\n};\nvar safeJoinHeaders = (headers, record) => {\n  const joinedHeaders = new Headers(record);\n  for (const [header, value] of headers.entries()) {\n    joinedHeaders.set(header, value);\n  }\n  return joinedHeaders;\n};\nvar processApi = (request, headers, upstashToken) => {\n  if (!request.api) {\n    request.headers = headers;\n    return request;\n  }\n  const { url, appendHeaders, owner, method } = getProviderInfo(request.api, upstashToken);\n  if (request.api.name === \"llm\") {\n    const callback = request.callback;\n    if (!callback) {\n      throw new TypeError(\"Callback cannot be undefined when using LLM api.\");\n    }\n    return {\n      ...request,\n      method: request.method ?? method,\n      headers: safeJoinHeaders(headers, appendHeaders),\n      ...owner === \"upstash\" && !request.api.analytics ? { api: { name: \"llm\" }, url: void 0, callback } : { url, api: void 0 }\n    };\n  } else {\n    return {\n      ...request,\n      method: request.method ?? method,\n      headers: safeJoinHeaders(headers, appendHeaders),\n      url,\n      api: void 0\n    };\n  }\n};\nfunction updateWithAnalytics(providerInfo, analytics) {\n  switch (analytics.name) {\n    case \"helicone\": {\n      providerInfo.appendHeaders[\"Helicone-Auth\"] = `Bearer ${analytics.token}`;\n      if (providerInfo.owner === \"upstash\") {\n        updateProviderInfo(providerInfo, \"https://qstash.helicone.ai\", [\n          \"llm\",\n          ...providerInfo.route\n        ]);\n      } else {\n        providerInfo.appendHeaders[\"Helicone-Target-Url\"] = providerInfo.baseUrl;\n        updateProviderInfo(providerInfo, \"https://gateway.helicone.ai\", providerInfo.route);\n      }\n      return providerInfo;\n    }\n    default: {\n      throw new Error(\"Unknown analytics provider\");\n    }\n  }\n}\nfunction updateProviderInfo(providerInfo, baseUrl, route) {\n  providerInfo.baseUrl = baseUrl;\n  providerInfo.route = route;\n  providerInfo.url = `${baseUrl}/${route.join(\"/\")}`;\n}\n\n// src/client/utils.ts\nvar isIgnoredHeader = (header) => {\n  const lowerCaseHeader = header.toLowerCase();\n  return lowerCaseHeader.startsWith(\"content-type\") || lowerCaseHeader.startsWith(\"upstash-\");\n};\nfunction prefixHeaders(headers) {\n  const keysToBePrefixed = [...headers.keys()].filter((key) => !isIgnoredHeader(key));\n  for (const key of keysToBePrefixed) {\n    const value = headers.get(key);\n    if (value !== null) {\n      headers.set(`Upstash-Forward-${key}`, value);\n    }\n    headers.delete(key);\n  }\n  return headers;\n}\nfunction wrapWithGlobalHeaders(headers, globalHeaders, telemetryHeaders) {\n  if (!globalHeaders) {\n    return headers;\n  }\n  const finalHeaders = new Headers(globalHeaders);\n  headers.forEach((value, key) => {\n    finalHeaders.set(key, value);\n  });\n  telemetryHeaders?.forEach((value, key) => {\n    if (!value)\n      return;\n    finalHeaders.append(key, value);\n  });\n  return finalHeaders;\n}\nfunction processHeaders(request) {\n  const headers = prefixHeaders(new Headers(request.headers));\n  headers.set(\"Upstash-Method\", request.method ?? \"POST\");\n  if (request.delay !== void 0) {\n    if (typeof request.delay === \"string\") {\n      headers.set(\"Upstash-Delay\", request.delay);\n    } else {\n      headers.set(\"Upstash-Delay\", `${request.delay.toFixed(0)}s`);\n    }\n  }\n  if (request.notBefore !== void 0) {\n    headers.set(\"Upstash-Not-Before\", request.notBefore.toFixed(0));\n  }\n  if (request.deduplicationId !== void 0) {\n    headers.set(\"Upstash-Deduplication-Id\", request.deduplicationId);\n  }\n  if (request.contentBasedDeduplication) {\n    headers.set(\"Upstash-Content-Based-Deduplication\", \"true\");\n  }\n  if (request.retries !== void 0) {\n    headers.set(\"Upstash-Retries\", request.retries.toFixed(0));\n  }\n  if (request.retryDelay !== void 0) {\n    headers.set(\"Upstash-Retry-Delay\", request.retryDelay);\n  }\n  if (request.callback !== void 0) {\n    headers.set(\"Upstash-Callback\", request.callback);\n  }\n  if (request.failureCallback !== void 0) {\n    headers.set(\"Upstash-Failure-Callback\", request.failureCallback);\n  }\n  if (request.timeout !== void 0) {\n    if (typeof request.timeout === \"string\") {\n      headers.set(\"Upstash-Timeout\", request.timeout);\n    } else {\n      headers.set(\"Upstash-Timeout\", `${request.timeout}s`);\n    }\n  }\n  if (request.flowControl?.key) {\n    const parallelism = request.flowControl.parallelism?.toString();\n    const rate = (request.flowControl.rate ?? request.flowControl.ratePerSecond)?.toString();\n    const period = typeof request.flowControl.period === \"number\" ? `${request.flowControl.period}s` : request.flowControl.period;\n    const controlValue = [\n      parallelism ? `parallelism=${parallelism}` : void 0,\n      rate ? `rate=${rate}` : void 0,\n      period ? `period=${period}` : void 0\n    ].filter(Boolean);\n    if (controlValue.length === 0) {\n      throw new QstashError(\"Provide at least one of parallelism or ratePerSecond for flowControl\");\n    }\n    headers.set(\"Upstash-Flow-Control-Key\", request.flowControl.key);\n    headers.set(\"Upstash-Flow-Control-Value\", controlValue.join(\", \"));\n  }\n  return headers;\n}\nfunction getRequestPath(request) {\n  const nonApiPath = request.url ?? request.urlGroup ?? request.topic;\n  if (nonApiPath)\n    return nonApiPath;\n  if (request.api?.name === \"llm\")\n    return `api/llm`;\n  if (request.api?.name === \"email\") {\n    const providerInfo = getProviderInfo(request.api, \"not-needed\");\n    return providerInfo.baseUrl;\n  }\n  throw new QstashError(`Failed to infer request path for ${JSON.stringify(request)}`);\n}\nvar NANOID_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\";\nvar NANOID_LENGTH = 21;\nfunction nanoid() {\n  return [...crypto.getRandomValues(new Uint8Array(NANOID_LENGTH))].map((x) => NANOID_CHARS[x % NANOID_CHARS.length]).join(\"\");\n}\nfunction decodeBase64(base64) {\n  try {\n    const binString = atob(base64);\n    const intArray = Uint8Array.from(binString, (m) => m.codePointAt(0));\n    return new TextDecoder().decode(intArray);\n  } catch (error) {\n    try {\n      const result = atob(base64);\n      console.warn(\n        `Upstash QStash: Failed while decoding base64 \"${base64}\". Decoding with atob and returning it instead. ${error}`\n      );\n      return result;\n    } catch (error2) {\n      console.warn(\n        `Upstash QStash: Failed to decode base64 \"${base64}\" with atob. Returning it as it is. ${error2}`\n      );\n      return base64;\n    }\n  }\n}\nfunction getRuntime() {\n  if (typeof process === \"object\" && typeof process.versions == \"object\" && process.versions.bun)\n    return `bun@${process.versions.bun}`;\n  if (typeof EdgeRuntime === \"string\")\n    return \"edge-light\";\n  else if (typeof process === \"object\" && typeof process.version === \"string\")\n    return `node@${process.version}`;\n  return \"\";\n}\n\n// src/client/queue.ts\nvar Queue = class {\n  http;\n  queueName;\n  constructor(http, queueName) {\n    this.http = http;\n    this.queueName = queueName;\n  }\n  /**\n   * Create or update the queue\n   */\n  async upsert(request) {\n    if (!this.queueName) {\n      throw new Error(\"Please provide a queue name to the Queue constructor\");\n    }\n    const body = {\n      queueName: this.queueName,\n      parallelism: request.parallelism ?? 1,\n      paused: request.paused ?? false\n    };\n    await this.http.request({\n      method: \"POST\",\n      path: [\"v2\", \"queues\"],\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Get the queue details\n   */\n  async get() {\n    if (!this.queueName) {\n      throw new Error(\"Please provide a queue name to the Queue constructor\");\n    }\n    return await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"queues\", this.queueName]\n    });\n  }\n  /**\n   * List queues\n   */\n  async list() {\n    return await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"queues\"]\n    });\n  }\n  /**\n   * Delete the queue\n   */\n  async delete() {\n    if (!this.queueName) {\n      throw new Error(\"Please provide a queue name to the Queue constructor\");\n    }\n    await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"queues\", this.queueName],\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Enqueue a message to a queue.\n   */\n  async enqueue(request) {\n    if (!this.queueName) {\n      throw new Error(\"Please provide a queue name to the Queue constructor\");\n    }\n    const headers = wrapWithGlobalHeaders(\n      processHeaders(request),\n      this.http.headers,\n      this.http.telemetryHeaders\n    );\n    const destination = getRequestPath(request);\n    const response = await this.http.request({\n      path: [\"v2\", \"enqueue\", this.queueName, destination],\n      body: request.body,\n      headers,\n      method: \"POST\"\n    });\n    return response;\n  }\n  /**\n   * Enqueue a message to a queue, serializing the body to JSON.\n   */\n  async enqueueJSON(request) {\n    const headers = prefixHeaders(new Headers(request.headers));\n    headers.set(\"Content-Type\", \"application/json\");\n    const upstashToken = String(this.http.authorization).split(\"Bearer \")[1];\n    const nonApiRequest = processApi(request, headers, upstashToken);\n    const response = await this.enqueue({\n      ...nonApiRequest,\n      body: JSON.stringify(nonApiRequest.body)\n    });\n    return response;\n  }\n  /**\n   * Pauses the queue.\n   *\n   * A paused queue will not deliver messages until\n   * it is resumed.\n   */\n  async pause() {\n    if (!this.queueName) {\n      throw new Error(\"Please provide a queue name to the Queue constructor\");\n    }\n    await this.http.request({\n      method: \"POST\",\n      path: [\"v2\", \"queues\", this.queueName, \"pause\"],\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Resumes the queue.\n   */\n  async resume() {\n    if (!this.queueName) {\n      throw new Error(\"Please provide a queue name to the Queue constructor\");\n    }\n    await this.http.request({\n      method: \"POST\",\n      path: [\"v2\", \"queues\", this.queueName, \"resume\"],\n      parseResponseAsJson: false\n    });\n  }\n};\n\n// src/client/schedules.ts\nvar Schedules = class {\n  http;\n  constructor(http) {\n    this.http = http;\n  }\n  /**\n   * Create a schedule\n   */\n  async create(request) {\n    const headers = prefixHeaders(new Headers(request.headers));\n    if (!headers.has(\"Content-Type\")) {\n      headers.set(\"Content-Type\", \"application/json\");\n    }\n    headers.set(\"Upstash-Cron\", request.cron);\n    if (request.method !== void 0) {\n      headers.set(\"Upstash-Method\", request.method);\n    }\n    if (request.delay !== void 0) {\n      if (typeof request.delay === \"string\") {\n        headers.set(\"Upstash-Delay\", request.delay);\n      } else {\n        headers.set(\"Upstash-Delay\", `${request.delay.toFixed(0)}s`);\n      }\n    }\n    if (request.retries !== void 0) {\n      headers.set(\"Upstash-Retries\", request.retries.toFixed(0));\n    }\n    if (request.retryDelay !== void 0) {\n      headers.set(\"Upstash-Retry-Delay\", request.retryDelay);\n    }\n    if (request.callback !== void 0) {\n      headers.set(\"Upstash-Callback\", request.callback);\n    }\n    if (request.failureCallback !== void 0) {\n      headers.set(\"Upstash-Failure-Callback\", request.failureCallback);\n    }\n    if (request.timeout !== void 0) {\n      if (typeof request.timeout === \"string\") {\n        headers.set(\"Upstash-Timeout\", request.timeout);\n      } else {\n        headers.set(\"Upstash-Timeout\", `${request.timeout}s`);\n      }\n    }\n    if (request.scheduleId !== void 0) {\n      headers.set(\"Upstash-Schedule-Id\", request.scheduleId);\n    }\n    if (request.queueName !== void 0) {\n      headers.set(\"Upstash-Queue-Name\", request.queueName);\n    }\n    if (request.flowControl?.key) {\n      const parallelism = request.flowControl.parallelism?.toString();\n      const rate = (request.flowControl.rate ?? request.flowControl.ratePerSecond)?.toString();\n      const period = typeof request.flowControl.period === \"number\" ? `${request.flowControl.period}s` : request.flowControl.period;\n      const controlValue = [\n        parallelism ? `parallelism=${parallelism}` : void 0,\n        rate ? `rate=${rate}` : void 0,\n        period ? `period=${period}` : void 0\n      ].filter(Boolean);\n      if (controlValue.length === 0) {\n        throw new QstashError(\n          \"Provide at least one of parallelism or ratePerSecond for flowControl\"\n        );\n      }\n      headers.set(\"Upstash-Flow-Control-Key\", request.flowControl.key);\n      headers.set(\"Upstash-Flow-Control-Value\", controlValue.join(\", \"));\n    }\n    return await this.http.request({\n      method: \"POST\",\n      headers: wrapWithGlobalHeaders(headers, this.http.headers, this.http.telemetryHeaders),\n      path: [\"v2\", \"schedules\", request.destination],\n      body: request.body\n    });\n  }\n  /**\n   * Get a schedule\n   */\n  async get(scheduleId) {\n    const schedule = await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"schedules\", scheduleId]\n    });\n    if (\"rate\" in schedule)\n      schedule.ratePerSecond = schedule.rate;\n    return schedule;\n  }\n  /**\n   * List your schedules\n   */\n  async list() {\n    const schedules = await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"schedules\"]\n    });\n    for (const schedule of schedules) {\n      if (\"rate\" in schedule)\n        schedule.ratePerSecond = schedule.rate;\n    }\n    return schedules;\n  }\n  /**\n   * Delete a schedule\n   */\n  async delete(scheduleId) {\n    return await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"schedules\", scheduleId],\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Pauses the schedule.\n   *\n   * A paused schedule will not deliver messages until\n   * it is resumed.\n   */\n  async pause({ schedule }) {\n    await this.http.request({\n      method: \"PATCH\",\n      path: [\"v2\", \"schedules\", schedule, \"pause\"],\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Resumes the schedule.\n   */\n  async resume({ schedule }) {\n    await this.http.request({\n      method: \"PATCH\",\n      path: [\"v2\", \"schedules\", schedule, \"resume\"],\n      parseResponseAsJson: false\n    });\n  }\n};\n\n// src/client/url-groups.ts\nvar UrlGroups = class {\n  http;\n  constructor(http) {\n    this.http = http;\n  }\n  /**\n   * Create a new url group with the given name and endpoints\n   */\n  async addEndpoints(request) {\n    await this.http.request({\n      method: \"POST\",\n      path: [\"v2\", \"topics\", request.name, \"endpoints\"],\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ endpoints: request.endpoints }),\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Remove endpoints from a url group.\n   */\n  async removeEndpoints(request) {\n    await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"topics\", request.name, \"endpoints\"],\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ endpoints: request.endpoints }),\n      parseResponseAsJson: false\n    });\n  }\n  /**\n   * Get a list of all url groups.\n   */\n  async list() {\n    return await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"topics\"]\n    });\n  }\n  /**\n   * Get a single url group\n   */\n  async get(name) {\n    return await this.http.request({\n      method: \"GET\",\n      path: [\"v2\", \"topics\", name]\n    });\n  }\n  /**\n   * Delete a url group\n   */\n  async delete(name) {\n    return await this.http.request({\n      method: \"DELETE\",\n      path: [\"v2\", \"topics\", name],\n      parseResponseAsJson: false\n    });\n  }\n};\n\n// version.ts\nvar VERSION = \"v2.8.2\";\n\n// src/client/client.ts\nvar Client = class {\n  http;\n  token;\n  constructor(config) {\n    const environment = typeof process === \"undefined\" ? {} : process.env;\n    let baseUrl = (config?.baseUrl ?? environment.QSTASH_URL ?? \"https://qstash.upstash.io\").replace(/\\/$/, \"\");\n    if (baseUrl === \"https://qstash.upstash.io/v2/publish\") {\n      baseUrl = \"https://qstash.upstash.io\";\n    }\n    const token = config?.token ?? environment.QSTASH_TOKEN;\n    const enableTelemetry = environment.UPSTASH_DISABLE_TELEMETRY ? false : config?.enableTelemetry ?? true;\n    const isCloudflare = typeof caches !== \"undefined\" && \"default\" in caches;\n    const telemetryHeaders = new Headers(\n      enableTelemetry ? {\n        \"Upstash-Telemetry-Sdk\": `upstash-qstash-js@${VERSION}`,\n        \"Upstash-Telemetry-Platform\": isCloudflare ? \"cloudflare\" : environment.VERCEL ? \"vercel\" : environment.AWS_REGION ? \"aws\" : \"\",\n        \"Upstash-Telemetry-Runtime\": getRuntime()\n      } : {}\n    );\n    this.http = new HttpClient({\n      retry: config?.retry,\n      baseUrl,\n      authorization: `Bearer ${token}`,\n      //@ts-expect-error caused by undici and bunjs type overlap\n      headers: prefixHeaders(new Headers(config?.headers ?? {})),\n      //@ts-expect-error caused by undici and bunjs type overlap\n      telemetryHeaders\n    });\n    if (!token) {\n      console.warn(\n        \"[Upstash QStash] client token is not set. Either pass a token or set QSTASH_TOKEN env variable.\"\n      );\n    }\n    this.token = token;\n  }\n  /**\n   * Access the urlGroup API.\n   *\n   * Create, read, update or delete urlGroups.\n   */\n  get urlGroups() {\n    return new UrlGroups(this.http);\n  }\n  /**\n   * Deprecated. Use urlGroups instead.\n   *\n   * Access the topic API.\n   *\n   * Create, read, update or delete topics.\n   */\n  get topics() {\n    return this.urlGroups;\n  }\n  /**\n   * Access the dlq API.\n   *\n   * List or remove messages from the DLQ.\n   */\n  get dlq() {\n    return new DLQ(this.http);\n  }\n  /**\n   * Access the message API.\n   *\n   * Read or cancel messages.\n   */\n  get messages() {\n    return new Messages(this.http);\n  }\n  /**\n   * Access the schedule API.\n   *\n   * Create, read or delete schedules.\n   */\n  get schedules() {\n    return new Schedules(this.http);\n  }\n  /**\n   * Access the workflow API.\n   *\n   * cancel workflows.\n   *\n   * @deprecated as of version 2.7.17. Will be removed in qstash-js 3.0.0.\n   * Please use @upstash/workflow instead https://github.com/upstash/workflow-js\n   * Migration Guide: https://upstash.com/docs/workflow/migration\n   */\n  get workflow() {\n    return new Workflow(this.http);\n  }\n  /**\n   * Access the queue API.\n   *\n   * Create, read, update or delete queues.\n   */\n  queue(request) {\n    return new Queue(this.http, request?.queueName);\n  }\n  /**\n   * Access the Chat API.\n   *\n   * @deprecated This will be removed in qstash-js 3.0.0. Please use an alternative SDK for interacting with LLMs.\n   *\n   * Use the create or prompt methods.\n   */\n  chat() {\n    return new Chat(this.http, this.token);\n  }\n  async publish(request) {\n    const headers = wrapWithGlobalHeaders(\n      processHeaders(request),\n      this.http.headers,\n      this.http.telemetryHeaders\n    );\n    const response = await this.http.request({\n      path: [\"v2\", \"publish\", getRequestPath(request)],\n      body: request.body,\n      headers,\n      method: \"POST\"\n    });\n    return response;\n  }\n  /**\n   * publishJSON is a utility wrapper around `publish` that automatically serializes the body\n   * and sets the `Content-Type` header to `application/json`.\n   */\n  async publishJSON(request) {\n    const headers = prefixHeaders(new Headers(request.headers));\n    headers.set(\"Content-Type\", \"application/json\");\n    const upstashToken = String(this.http.authorization).split(\"Bearer \")[1];\n    const nonApiRequest = processApi(request, headers, upstashToken);\n    const response = await this.publish({\n      ...nonApiRequest,\n      body: JSON.stringify(nonApiRequest.body)\n    });\n    return response;\n  }\n  /**\n   * Batch publish messages to QStash.\n   */\n  async batch(request) {\n    const messages = [];\n    for (const message of request) {\n      const headers = wrapWithGlobalHeaders(\n        processHeaders(message),\n        this.http.headers,\n        this.http.telemetryHeaders\n      );\n      const headerEntries = Object.fromEntries(headers.entries());\n      messages.push({\n        destination: getRequestPath(message),\n        headers: headerEntries,\n        body: message.body,\n        ...message.queueName && { queue: message.queueName }\n      });\n    }\n    const response = await this.http.request({\n      path: [\"v2\", \"batch\"],\n      body: JSON.stringify(messages),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      method: \"POST\"\n    });\n    const arrayResposne = Array.isArray(response) ? response : [response];\n    return arrayResposne;\n  }\n  /**\n   * Batch publish messages to QStash, serializing each body to JSON.\n   */\n  async batchJSON(request) {\n    const batchPayload = request.map((message) => {\n      if (\"body\" in message) {\n        message.body = JSON.stringify(message.body);\n      }\n      const upstashToken = String(this.http.authorization).split(\"Bearer \")[1];\n      const nonApiMessage = processApi(message, new Headers(message.headers), upstashToken);\n      nonApiMessage.headers.set(\"Content-Type\", \"application/json\");\n      return nonApiMessage;\n    });\n    const response = await this.batch(batchPayload);\n    return response;\n  }\n  /**\n   * Retrieve your logs.\n   *\n   * The logs endpoint is paginated and returns only 100 logs at a time.\n   * If you want to receive more logs, you can use the cursor to paginate.\n   *\n   * The cursor is a unix timestamp with millisecond precision\n   *\n   * @example\n   * ```ts\n   * let cursor = Date.now()\n   * const logs: Log[] = []\n   * while (cursor > 0) {\n   *   const res = await qstash.logs({ cursor })\n   *   logs.push(...res.logs)\n   *   cursor = res.cursor ?? 0\n   * }\n   * ```\n   */\n  async logs(request) {\n    const query = {};\n    if (typeof request?.cursor === \"number\" && request.cursor > 0) {\n      query.cursor = request.cursor.toString();\n    } else if (typeof request?.cursor === \"string\" && request.cursor !== \"\") {\n      query.cursor = request.cursor;\n    }\n    for (const [key, value] of Object.entries(request?.filter ?? {})) {\n      if (typeof value === \"number\" && value < 0) {\n        continue;\n      }\n      if (key === \"urlGroup\") {\n        query.topicName = value.toString();\n      } else if (typeof value !== \"undefined\") {\n        query[key] = value.toString();\n      }\n    }\n    const responsePayload = await this.http.request({\n      path: [\"v2\", \"events\"],\n      method: \"GET\",\n      query\n    });\n    const logs = responsePayload.events.map((event) => {\n      return {\n        ...event,\n        urlGroup: event.topicName\n      };\n    });\n    return {\n      cursor: responsePayload.cursor,\n      logs,\n      events: logs\n    };\n  }\n  /**\n   * @deprecated Will be removed in the next major release. Use the `logs` method instead.\n   *\n   * Retrieve your logs.\n   *\n   * The logs endpoint is paginated and returns only 100 logs at a time.\n   * If you want to receive more logs, you can use the cursor to paginate.\n   *\n   * The cursor is a unix timestamp with millisecond precision\n   *\n   * @example\n   * ```ts\n   * let cursor = Date.now()\n   * const logs: Log[] = []\n   * while (cursor > 0) {\n   *   const res = await qstash.logs({ cursor })\n   *   logs.push(...res.logs)\n   *   cursor = res.cursor ?? 0\n   * }\n   * ```\n   */\n  async events(request) {\n    return await this.logs(request);\n  }\n};\n\n// src/client/workflow/constants.ts\nvar WORKFLOW_ID_HEADER = \"Upstash-Workflow-RunId\";\nvar WORKFLOW_INIT_HEADER = \"Upstash-Workflow-Init\";\nvar WORKFLOW_URL_HEADER = \"Upstash-Workflow-Url\";\nvar WORKFLOW_FAILURE_HEADER = \"Upstash-Workflow-Is-Failure\";\nvar WORKFLOW_PROTOCOL_VERSION = \"1\";\nvar WORKFLOW_PROTOCOL_VERSION_HEADER = \"Upstash-Workflow-Sdk-Version\";\nvar DEFAULT_CONTENT_TYPE = \"application/json\";\nvar NO_CONCURRENCY = 1;\nvar DEFAULT_RETRIES = 3;\n\n// src/client/workflow/context.ts\nimport { err as err2, ok as ok2 } from \"neverthrow\";\n\n// src/client/workflow/workflow-requests.ts\nimport { err, ok } from \"neverthrow\";\n\n// src/client/workflow/types.ts\nvar StepTypes = [\"Initial\", \"Run\", \"SleepFor\", \"SleepUntil\", \"Call\"];\n\n// src/client/workflow/workflow-requests.ts\nvar triggerFirstInvocation = async (workflowContext, retries, debug) => {\n  const headers = getHeaders(\n    \"true\",\n    workflowContext.workflowRunId,\n    workflowContext.url,\n    workflowContext.headers,\n    void 0,\n    workflowContext.failureUrl,\n    retries\n  );\n  await debug?.log(\"SUBMIT\", \"SUBMIT_FIRST_INVOCATION\", {\n    headers,\n    requestPayload: workflowContext.requestPayload,\n    url: workflowContext.url\n  });\n  try {\n    await workflowContext.qstashClient.publishJSON({\n      headers,\n      method: \"POST\",\n      body: workflowContext.requestPayload,\n      url: workflowContext.url\n    });\n    return ok(\"success\");\n  } catch (error) {\n    const error_ = error;\n    return err(error_);\n  }\n};\nvar triggerRouteFunction = async ({\n  onCleanup,\n  onStep\n}) => {\n  try {\n    await onStep();\n    await onCleanup();\n    return ok(\"workflow-finished\");\n  } catch (error) {\n    const error_ = error;\n    return error_ instanceof QStashWorkflowAbort ? ok(\"step-finished\") : err(error_);\n  }\n};\nvar triggerWorkflowDelete = async (workflowContext, debug, cancel = false) => {\n  await debug?.log(\"SUBMIT\", \"SUBMIT_CLEANUP\", {\n    deletedWorkflowRunId: workflowContext.workflowRunId\n  });\n  const result = await workflowContext.qstashClient.http.request({\n    path: [\"v2\", \"workflows\", \"runs\", `${workflowContext.workflowRunId}?cancel=${cancel}`],\n    method: \"DELETE\",\n    parseResponseAsJson: false\n  });\n  await debug?.log(\"SUBMIT\", \"SUBMIT_CLEANUP\", result);\n};\nvar recreateUserHeaders = (headers) => {\n  const filteredHeaders = new Headers();\n  const pairs = headers.entries();\n  for (const [header, value] of pairs) {\n    const headerLowerCase = header.toLowerCase();\n    if (!headerLowerCase.startsWith(\"upstash-workflow-\") && !headerLowerCase.startsWith(\"x-vercel-\") && !headerLowerCase.startsWith(\"x-forwarded-\") && headerLowerCase !== \"cf-connecting-ip\") {\n      filteredHeaders.append(header, value);\n    }\n  }\n  return filteredHeaders;\n};\nvar handleThirdPartyCallResult = async (request, requestPayload, client, workflowUrl, failureUrl, retries, debug) => {\n  try {\n    if (request.headers.get(\"Upstash-Workflow-Callback\")) {\n      const callbackMessage = JSON.parse(requestPayload);\n      if (!(callbackMessage.status >= 200 && callbackMessage.status < 300)) {\n        await debug?.log(\"WARN\", \"SUBMIT_THIRD_PARTY_RESULT\", {\n          status: callbackMessage.status,\n          body: atob(callbackMessage.body)\n        });\n        console.warn(\n          `Workflow Warning: \"context.call\" failed with status ${callbackMessage.status} and will retry (if there are retries remaining). Error Message:\n${atob(callbackMessage.body)}`\n        );\n        return ok(\"call-will-retry\");\n      }\n      const workflowRunId = request.headers.get(WORKFLOW_ID_HEADER);\n      const stepIdString = request.headers.get(\"Upstash-Workflow-StepId\");\n      const stepName = request.headers.get(\"Upstash-Workflow-StepName\");\n      const stepType = request.headers.get(\"Upstash-Workflow-StepType\");\n      const concurrentString = request.headers.get(\"Upstash-Workflow-Concurrent\");\n      const contentType = request.headers.get(\"Upstash-Workflow-ContentType\");\n      if (!(workflowRunId && stepIdString && stepName && StepTypes.includes(stepType) && concurrentString && contentType)) {\n        throw new Error(\n          `Missing info in callback message source header: ${JSON.stringify({\n            workflowRunId,\n            stepIdString,\n            stepName,\n            stepType,\n            concurrentString,\n            contentType\n          })}`\n        );\n      }\n      const userHeaders = recreateUserHeaders(request.headers);\n      const requestHeaders = getHeaders(\n        \"false\",\n        workflowRunId,\n        workflowUrl,\n        userHeaders,\n        void 0,\n        failureUrl,\n        retries\n      );\n      const callResultStep = {\n        stepId: Number(stepIdString),\n        stepName,\n        stepType,\n        out: atob(callbackMessage.body),\n        concurrent: Number(concurrentString)\n      };\n      await debug?.log(\"SUBMIT\", \"SUBMIT_THIRD_PARTY_RESULT\", {\n        step: callResultStep,\n        headers: requestHeaders,\n        url: workflowUrl\n      });\n      const result = await client.publishJSON({\n        headers: requestHeaders,\n        method: \"POST\",\n        body: callResultStep,\n        url: workflowUrl\n      });\n      await debug?.log(\"SUBMIT\", \"SUBMIT_THIRD_PARTY_RESULT\", {\n        messageId: result.messageId\n      });\n      return ok(\"is-call-return\");\n    } else {\n      return ok(\"continue-workflow\");\n    }\n  } catch (error) {\n    const isCallReturn = request.headers.get(\"Upstash-Workflow-Callback\");\n    return err(\n      new QStashWorkflowError(\n        `Error when handling call return (isCallReturn=${isCallReturn}): ${error}`\n      )\n    );\n  }\n};\nvar getHeaders = (initHeaderValue, workflowRunId, workflowUrl, userHeaders, step, failureUrl, retries) => {\n  const baseHeaders = {\n    [WORKFLOW_INIT_HEADER]: initHeaderValue,\n    [WORKFLOW_ID_HEADER]: workflowRunId,\n    [WORKFLOW_URL_HEADER]: workflowUrl,\n    [`Upstash-Forward-${WORKFLOW_PROTOCOL_VERSION_HEADER}`]: WORKFLOW_PROTOCOL_VERSION,\n    ...failureUrl ? {\n      [`Upstash-Failure-Callback-Forward-${WORKFLOW_FAILURE_HEADER}`]: \"true\",\n      \"Upstash-Failure-Callback\": failureUrl\n    } : {},\n    ...retries === void 0 ? {} : {\n      \"Upstash-Retries\": retries.toString()\n    }\n  };\n  if (userHeaders) {\n    for (const header of userHeaders.keys()) {\n      if (step?.callHeaders) {\n        baseHeaders[`Upstash-Callback-Forward-${header}`] = userHeaders.get(header);\n      } else {\n        baseHeaders[`Upstash-Forward-${header}`] = userHeaders.get(header);\n      }\n    }\n  }\n  if (step?.callHeaders) {\n    const forwardedHeaders = Object.fromEntries(\n      Object.entries(step.callHeaders).map(([header, value]) => [\n        `Upstash-Forward-${header}`,\n        value\n      ])\n    );\n    const contentType = step.callHeaders[\"Content-Type\"];\n    return {\n      ...baseHeaders,\n      ...forwardedHeaders,\n      \"Upstash-Callback\": workflowUrl,\n      \"Upstash-Callback-Workflow-RunId\": workflowRunId,\n      \"Upstash-Callback-Workflow-CallType\": \"fromCallback\",\n      \"Upstash-Callback-Workflow-Init\": \"false\",\n      \"Upstash-Callback-Workflow-Url\": workflowUrl,\n      \"Upstash-Callback-Forward-Upstash-Workflow-Callback\": \"true\",\n      \"Upstash-Callback-Forward-Upstash-Workflow-StepId\": step.stepId.toString(),\n      \"Upstash-Callback-Forward-Upstash-Workflow-StepName\": step.stepName,\n      \"Upstash-Callback-Forward-Upstash-Workflow-StepType\": step.stepType,\n      \"Upstash-Callback-Forward-Upstash-Workflow-Concurrent\": step.concurrent.toString(),\n      \"Upstash-Callback-Forward-Upstash-Workflow-ContentType\": contentType ?? DEFAULT_CONTENT_TYPE,\n      \"Upstash-Workflow-CallType\": \"toCallback\"\n    };\n  }\n  return baseHeaders;\n};\nvar verifyRequest = async (body, signature, verifier) => {\n  if (!verifier) {\n    return;\n  }\n  try {\n    if (!signature) {\n      throw new Error(\"`Upstash-Signature` header is not passed.\");\n    }\n    const isValid = await verifier.verify({\n      body,\n      signature\n    });\n    if (!isValid) {\n      throw new Error(\"Signature in `Upstash-Signature` header is not valid\");\n    }\n  } catch (error) {\n    throw new QStashWorkflowError(\n      `Failed to verify that the Workflow request comes from QStash: ${error}\n\nIf signature is missing, trigger the workflow endpoint by publishing your request to QStash instead of calling it directly.\n\nIf you want to disable QStash Verification, you should clear env variables QSTASH_CURRENT_SIGNING_KEY and QSTASH_NEXT_SIGNING_KEY`\n    );\n  }\n};\n\n// src/client/workflow/auto-executor.ts\nvar AutoExecutor = class _AutoExecutor {\n  context;\n  promises = /* @__PURE__ */ new WeakMap();\n  activeLazyStepList;\n  debug;\n  nonPlanStepCount;\n  steps;\n  indexInCurrentList = 0;\n  stepCount = 0;\n  planStepCount = 0;\n  executingStep = false;\n  constructor(context, steps, debug) {\n    this.context = context;\n    this.debug = debug;\n    this.steps = steps;\n    this.nonPlanStepCount = this.steps.filter((step) => !step.targetStep).length;\n  }\n  /**\n   * Adds the step function to the list of step functions to run in\n   * parallel. After adding the function, defers the execution, so\n   * that if there is another step function to be added, it's also\n   * added.\n   *\n   * After all functions are added, list of functions are executed.\n   * If there is a single function, it's executed by itself. If there\n   * are multiple, they are run in parallel.\n   *\n   * If a function is already executing (this.executingStep), this\n   * means that there is a nested step which is not allowed. In this\n   * case, addStep throws QStashWorkflowError.\n   *\n   * @param stepInfo step plan to add\n   * @returns result of the step function\n   */\n  async addStep(stepInfo) {\n    if (this.executingStep) {\n      throw new QStashWorkflowError(\n        `A step can not be run inside another step. Tried to run '${stepInfo.stepName}' inside '${this.executingStep}'`\n      );\n    }\n    this.stepCount += 1;\n    const lazyStepList = this.activeLazyStepList ?? [];\n    if (!this.activeLazyStepList) {\n      this.activeLazyStepList = lazyStepList;\n      this.indexInCurrentList = 0;\n    }\n    lazyStepList.push(stepInfo);\n    const index = this.indexInCurrentList++;\n    const requestComplete = this.deferExecution().then(async () => {\n      if (!this.promises.has(lazyStepList)) {\n        const promise2 = this.getExecutionPromise(lazyStepList);\n        this.promises.set(lazyStepList, promise2);\n        this.activeLazyStepList = void 0;\n        this.planStepCount += lazyStepList.length > 1 ? lazyStepList.length : 0;\n      }\n      const promise = this.promises.get(lazyStepList);\n      return promise;\n    });\n    const result = await requestComplete;\n    return _AutoExecutor.getResult(lazyStepList, result, index);\n  }\n  /**\n   * Wraps a step function to set this.executingStep to step name\n   * before running and set this.executingStep to False after execution\n   * ends.\n   *\n   * this.executingStep allows us to detect nested steps which are not\n   * allowed.\n   *\n   * @param stepName name of the step being wrapped\n   * @param stepFunction step function to wrap\n   * @returns wrapped step function\n   */\n  wrapStep(stepName, stepFunction) {\n    this.executingStep = stepName;\n    const result = stepFunction();\n    this.executingStep = false;\n    return result;\n  }\n  /**\n   * Executes a step:\n   * - If the step result is available in the steps, returns the result\n   * - If the result is not avaiable, runs the function\n   * - Sends the result to QStash\n   *\n   * @param lazyStep lazy step to execute\n   * @returns step result\n   */\n  async runSingle(lazyStep) {\n    if (this.stepCount < this.nonPlanStepCount) {\n      const step = this.steps[this.stepCount + this.planStepCount];\n      validateStep(lazyStep, step);\n      await this.debug?.log(\"INFO\", \"RUN_SINGLE\", {\n        fromRequest: true,\n        step,\n        stepCount: this.stepCount\n      });\n      return step.out;\n    }\n    const resultStep = await lazyStep.getResultStep(NO_CONCURRENCY, this.stepCount);\n    await this.debug?.log(\"INFO\", \"RUN_SINGLE\", {\n      fromRequest: false,\n      step: resultStep,\n      stepCount: this.stepCount\n    });\n    await this.submitStepsToQStash([resultStep]);\n    return resultStep.out;\n  }\n  /**\n   * Runs steps in parallel.\n   *\n   * @param stepName parallel step name\n   * @param stepFunctions list of async functions to run in parallel\n   * @returns results of the functions run in parallel\n   */\n  async runParallel(parallelSteps) {\n    const initialStepCount = this.stepCount - (parallelSteps.length - 1);\n    const parallelCallState = this.getParallelCallState(parallelSteps.length, initialStepCount);\n    const sortedSteps = sortSteps(this.steps);\n    const plannedParallelStepCount = sortedSteps[initialStepCount + this.planStepCount]?.concurrent;\n    if (parallelCallState !== \"first\" && plannedParallelStepCount !== parallelSteps.length) {\n      throw new QStashWorkflowError(\n        `Incompatible number of parallel steps when call state was '${parallelCallState}'. Expected ${parallelSteps.length}, got ${plannedParallelStepCount} from the request.`\n      );\n    }\n    await this.debug?.log(\"INFO\", \"RUN_PARALLEL\", {\n      parallelCallState,\n      initialStepCount,\n      plannedParallelStepCount,\n      stepCount: this.stepCount,\n      planStepCount: this.planStepCount\n    });\n    switch (parallelCallState) {\n      case \"first\": {\n        const planSteps = parallelSteps.map(\n          (parallelStep, index) => parallelStep.getPlanStep(parallelSteps.length, initialStepCount + index)\n        );\n        await this.submitStepsToQStash(planSteps);\n        break;\n      }\n      case \"partial\": {\n        const planStep = this.steps.at(-1);\n        if (!planStep || planStep.targetStep === void 0) {\n          throw new QStashWorkflowError(\n            `There must be a last step and it should have targetStep larger than 0.Received: ${JSON.stringify(planStep)}`\n          );\n        }\n        const stepIndex = planStep.targetStep - initialStepCount;\n        validateStep(parallelSteps[stepIndex], planStep);\n        try {\n          const resultStep = await parallelSteps[stepIndex].getResultStep(\n            parallelSteps.length,\n            planStep.targetStep\n          );\n          await this.submitStepsToQStash([resultStep]);\n        } catch (error) {\n          if (error instanceof QStashWorkflowAbort) {\n            throw error;\n          }\n          throw new QStashWorkflowError(\n            `Error submitting steps to QStash in partial parallel step execution: ${error}`\n          );\n        }\n        break;\n      }\n      case \"discard\": {\n        throw new QStashWorkflowAbort(\"discarded parallel\");\n      }\n      case \"last\": {\n        const parallelResultSteps = sortedSteps.filter((step) => step.stepId >= initialStepCount).slice(0, parallelSteps.length);\n        validateParallelSteps(parallelSteps, parallelResultSteps);\n        return parallelResultSteps.map((step) => step.out);\n      }\n    }\n    const fillValue = void 0;\n    return Array.from({ length: parallelSteps.length }).fill(fillValue);\n  }\n  /**\n   * Determines the parallel call state\n   *\n   * First filters the steps to get the steps which are after `initialStepCount` parameter.\n   *\n   * Depending on the remaining steps, decides the parallel state:\n   * - \"first\": If there are no steps\n   * - \"last\" If there are equal to or more than `2 * parallelStepCount`. We multiply by two\n   *   because each step in a parallel execution will have 2 steps: a plan step and a result\n   *   step.\n   * - \"partial\": If the last step is a plan step\n   * - \"discard\": If the last step is not a plan step. This means that the parallel execution\n   *   is in progress (there are still steps to run) and one step has finished and submitted\n   *   its result to QStash\n   *\n   * @param parallelStepCount number of steps to run in parallel\n   * @param initialStepCount steps after the parallel invocation\n   * @returns parallel call state\n   */\n  getParallelCallState(parallelStepCount, initialStepCount) {\n    const remainingSteps = this.steps.filter(\n      (step) => (step.targetStep ?? step.stepId) >= initialStepCount\n    );\n    if (remainingSteps.length === 0) {\n      return \"first\";\n    } else if (remainingSteps.length >= 2 * parallelStepCount) {\n      return \"last\";\n    } else if (remainingSteps.at(-1)?.targetStep) {\n      return \"partial\";\n    } else {\n      return \"discard\";\n    }\n  }\n  /**\n   * sends the steps to QStash as batch\n   *\n   * @param steps steps to send\n   */\n  async submitStepsToQStash(steps) {\n    if (steps.length === 0) {\n      throw new QStashWorkflowError(\n        `Unable to submit steps to QStash. Provided list is empty. Current step: ${this.stepCount}`\n      );\n    }\n    await this.debug?.log(\"SUBMIT\", \"SUBMIT_STEP\", { length: steps.length, steps });\n    const result = await this.context.qstashClient.batchJSON(\n      steps.map((singleStep) => {\n        const headers = getHeaders(\n          \"false\",\n          this.context.workflowRunId,\n          this.context.url,\n          this.context.headers,\n          singleStep,\n          this.context.failureUrl,\n          this.context.retries\n        );\n        const willWait = singleStep.concurrent === NO_CONCURRENCY || singleStep.stepId === 0;\n        return singleStep.callUrl ? (\n          // if the step is a third party call, we call the third party\n          // url (singleStep.callUrl) and pass information about the workflow\n          // in the headers (handled in getHeaders). QStash makes the request\n          // to callUrl and returns the result to Workflow endpoint.\n          // handleThirdPartyCallResult method sends the result of the third\n          // party call to QStash.\n          {\n            headers,\n            method: singleStep.callMethod,\n            body: singleStep.callBody,\n            url: singleStep.callUrl\n          }\n        ) : (\n          // if the step is not a third party call, we use workflow\n          // endpoint (context.url) as URL when calling QStash. QStash\n          // calls us back with the updated steps list.\n          {\n            headers,\n            method: \"POST\",\n            body: singleStep,\n            url: this.context.url,\n            notBefore: willWait ? singleStep.sleepUntil : void 0,\n            delay: willWait ? singleStep.sleepFor : void 0\n          }\n        );\n      })\n    );\n    await this.debug?.log(\"INFO\", \"SUBMIT_STEP\", {\n      messageIds: result.map((message) => {\n        return {\n          message: message.messageId\n        };\n      })\n    });\n    throw new QStashWorkflowAbort(steps[0].stepName, steps[0]);\n  }\n  /**\n   * Get the promise by executing the lazt steps list. If there is a single\n   * step, we call `runSingle`. Otherwise `runParallel` is called.\n   *\n   * @param lazyStepList steps list to execute\n   * @returns promise corresponding to the execution\n   */\n  getExecutionPromise(lazyStepList) {\n    return lazyStepList.length === 1 ? this.runSingle(lazyStepList[0]) : this.runParallel(lazyStepList);\n  }\n  /**\n   * @param lazyStepList steps we executed\n   * @param result result of the promise from `getExecutionPromise`\n   * @param index index of the current step\n   * @returns result[index] if lazyStepList > 1, otherwise result\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\n  static getResult(lazyStepList, result, index) {\n    if (lazyStepList.length === 1) {\n      return result;\n    } else if (Array.isArray(result) && lazyStepList.length === result.length && index < lazyStepList.length) {\n      return result[index];\n    } else {\n      throw new QStashWorkflowError(\n        `Unexpected parallel call result while executing step ${index}: '${result}'. Expected ${lazyStepList.length} many items`\n      );\n    }\n  }\n  async deferExecution() {\n    await Promise.resolve();\n    await Promise.resolve();\n  }\n};\nvar validateStep = (lazyStep, stepFromRequest) => {\n  if (lazyStep.stepName !== stepFromRequest.stepName) {\n    throw new QStashWorkflowError(\n      `Incompatible step name. Expected '${lazyStep.stepName}', got '${stepFromRequest.stepName}' from the request`\n    );\n  }\n  if (lazyStep.stepType !== stepFromRequest.stepType) {\n    throw new QStashWorkflowError(\n      `Incompatible step type. Expected '${lazyStep.stepType}', got '${stepFromRequest.stepType}' from the request`\n    );\n  }\n};\nvar validateParallelSteps = (lazySteps, stepsFromRequest) => {\n  try {\n    for (const [index, stepFromRequest] of stepsFromRequest.entries()) {\n      validateStep(lazySteps[index], stepFromRequest);\n    }\n  } catch (error) {\n    if (error instanceof QStashWorkflowError) {\n      const lazyStepNames = lazySteps.map((lazyStep) => lazyStep.stepName);\n      const lazyStepTypes = lazySteps.map((lazyStep) => lazyStep.stepType);\n      const requestStepNames = stepsFromRequest.map((step) => step.stepName);\n      const requestStepTypes = stepsFromRequest.map((step) => step.stepType);\n      throw new QStashWorkflowError(\n        `Incompatible steps detected in parallel execution: ${error.message}\n  > Step Names from the request: ${JSON.stringify(requestStepNames)}\n    Step Types from the request: ${JSON.stringify(requestStepTypes)}\n  > Step Names expected: ${JSON.stringify(lazyStepNames)}\n    Step Types expected: ${JSON.stringify(lazyStepTypes)}`\n      );\n    }\n    throw error;\n  }\n};\nvar sortSteps = (steps) => {\n  const getStepId = (step) => step.targetStep ?? step.stepId;\n  return [...steps].sort((step, stepOther) => getStepId(step) - getStepId(stepOther));\n};\n\n// src/client/workflow/steps.ts\nvar BaseLazyStep = class {\n  stepName;\n  // will be set in the subclasses\n  constructor(stepName) {\n    this.stepName = stepName;\n  }\n};\nvar LazyFunctionStep = class extends BaseLazyStep {\n  stepFunction;\n  stepType = \"Run\";\n  constructor(stepName, stepFunction) {\n    super(stepName);\n    this.stepFunction = stepFunction;\n  }\n  getPlanStep(concurrent, targetStep) {\n    {\n      return {\n        stepId: 0,\n        stepName: this.stepName,\n        stepType: this.stepType,\n        concurrent,\n        targetStep\n      };\n    }\n  }\n  async getResultStep(concurrent, stepId) {\n    let result = this.stepFunction();\n    if (result instanceof Promise) {\n      result = await result;\n    }\n    return {\n      stepId,\n      stepName: this.stepName,\n      stepType: this.stepType,\n      out: result,\n      concurrent\n    };\n  }\n};\nvar LazySleepStep = class extends BaseLazyStep {\n  sleep;\n  stepType = \"SleepFor\";\n  constructor(stepName, sleep) {\n    super(stepName);\n    this.sleep = sleep;\n  }\n  getPlanStep(concurrent, targetStep) {\n    {\n      return {\n        stepId: 0,\n        stepName: this.stepName,\n        stepType: this.stepType,\n        sleepFor: this.sleep,\n        concurrent,\n        targetStep\n      };\n    }\n  }\n  async getResultStep(concurrent, stepId) {\n    return await Promise.resolve({\n      stepId,\n      stepName: this.stepName,\n      stepType: this.stepType,\n      sleepFor: this.sleep,\n      concurrent\n    });\n  }\n};\nvar LazySleepUntilStep = class extends BaseLazyStep {\n  sleepUntil;\n  stepType = \"SleepUntil\";\n  constructor(stepName, sleepUntil) {\n    super(stepName);\n    this.sleepUntil = sleepUntil;\n  }\n  getPlanStep(concurrent, targetStep) {\n    {\n      return {\n        stepId: 0,\n        stepName: this.stepName,\n        stepType: this.stepType,\n        sleepUntil: this.sleepUntil,\n        concurrent,\n        targetStep\n      };\n    }\n  }\n  async getResultStep(concurrent, stepId) {\n    return await Promise.resolve({\n      stepId,\n      stepName: this.stepName,\n      stepType: this.stepType,\n      sleepUntil: this.sleepUntil,\n      concurrent\n    });\n  }\n};\nvar LazyCallStep = class extends BaseLazyStep {\n  url;\n  method;\n  body;\n  headers;\n  stepType = \"Call\";\n  constructor(stepName, url, method, body, headers) {\n    super(stepName);\n    this.url = url;\n    this.method = method;\n    this.body = body;\n    this.headers = headers;\n  }\n  getPlanStep(concurrent, targetStep) {\n    {\n      return {\n        stepId: 0,\n        stepName: this.stepName,\n        stepType: this.stepType,\n        concurrent,\n        targetStep\n      };\n    }\n  }\n  async getResultStep(concurrent, stepId) {\n    return await Promise.resolve({\n      stepId,\n      stepName: this.stepName,\n      stepType: this.stepType,\n      concurrent,\n      callUrl: this.url,\n      callMethod: this.method,\n      callBody: this.body,\n      callHeaders: this.headers\n    });\n  }\n};\n\n// src/client/workflow/context.ts\nvar WorkflowContext = class {\n  executor;\n  steps;\n  /**\n   * QStash client of the workflow\n   *\n   * Can be overwritten by passing `qstashClient` parameter in `serve`:\n   *\n   * ```ts\n   * import { Client } from \"@upstash/qstash\"\n   *\n   * export const POST = serve(\n   *   async (context) => {\n   *     ...\n   *   },\n   *   {\n   *     qstashClient: new Client({...})\n   *   }\n   * )\n   * ```\n   */\n  qstashClient;\n  /**\n   * Run id of the workflow\n   */\n  workflowRunId;\n  /**\n   * URL of the workflow\n   *\n   * Can be overwritten by passing a `url` parameter in `serve`:\n   *\n   * ```ts\n   * export const POST = serve(\n   *   async (context) => {\n   *     ...\n   *   },\n   *   {\n   *     url: \"new-url-value\"\n   *   }\n   * )\n   * ```\n   */\n  url;\n  /**\n   * URL to call in case of workflow failure with QStash failure callback\n   *\n   * https://upstash.com/docs/qstash/features/callbacks#what-is-a-failure-callback\n   *\n   * Can be overwritten by passing a `failureUrl` parameter in `serve`:\n   *\n   * ```ts\n   * export const POST = serve(\n   *   async (context) => {\n   *     ...\n   *   },\n   *   {\n   *     failureUrl: \"new-url-value\"\n   *   }\n   * )\n   * ```\n   */\n  failureUrl;\n  /**\n   * Payload of the request which started the workflow.\n   *\n   * To specify its type, you can define `serve` as follows:\n   *\n   * ```ts\n   * // set requestPayload type to MyPayload:\n   * export const POST = serve<MyPayload>(\n   *   async (context) => {\n   *     ...\n   *   }\n   * )\n   * ```\n   *\n   * By default, `serve` tries to apply `JSON.parse` to the request payload.\n   * If your payload is encoded in a format other than JSON, you can utilize\n   * the `initialPayloadParser` parameter:\n   *\n   * ```ts\n   * export const POST = serve<MyPayload>(\n   *   async (context) => {\n   *     ...\n   *   },\n   *   {\n   *     initialPayloadParser: (initialPayload) => {return doSomething(initialPayload)}\n   *   }\n   * )\n   * ```\n   */\n  requestPayload;\n  /**\n   * headers of the initial request\n   */\n  headers;\n  /**\n   * initial payload as a raw string\n   */\n  rawInitialPayload;\n  /**\n   * Map of environment variables and their values.\n   *\n   * Can be set using the `env` option of serve:\n   *\n   * ```ts\n   * export const POST = serve<MyPayload>(\n   *   async (context) => {\n   *     const key = context.env[\"API_KEY\"];\n   *   },\n   *   {\n   *     env: {\n   *       \"API_KEY\": \"*****\";\n   *     }\n   *   }\n   * )\n   * ```\n   *\n   * Default value is set to `process.env`.\n   */\n  env;\n  /**\n   * Number of retries\n   */\n  retries;\n  constructor({\n    qstashClient,\n    workflowRunId,\n    headers,\n    steps,\n    url,\n    failureUrl,\n    debug,\n    initialPayload,\n    rawInitialPayload,\n    env,\n    retries\n  }) {\n    this.qstashClient = qstashClient;\n    this.workflowRunId = workflowRunId;\n    this.steps = steps;\n    this.url = url;\n    this.failureUrl = failureUrl;\n    this.headers = headers;\n    this.requestPayload = initialPayload;\n    this.rawInitialPayload = rawInitialPayload ?? JSON.stringify(this.requestPayload);\n    this.env = env ?? {};\n    this.retries = retries ?? DEFAULT_RETRIES;\n    this.executor = new AutoExecutor(this, this.steps, debug);\n  }\n  /**\n   * Executes a workflow step\n   *\n   * ```typescript\n   * const result = await context.run(\"step 1\", () => {\n   *   return \"result\"\n   * })\n   * ```\n   *\n   * Can also be called in parallel and the steps will be executed\n   * simulatenously:\n   *\n   * ```typescript\n   * const [result1, result2] = await Promise.all([\n   *   context.run(\"step 1\", () => {\n   *     return \"result1\"\n   *   })\n   *   context.run(\"step 2\", async () => {\n   *     return await fetchResults()\n   *   })\n   * ])\n   * ```\n   *\n   * @param stepName name of the step\n   * @param stepFunction step function to be executed\n   * @returns result of the step function\n   */\n  async run(stepName, stepFunction) {\n    const wrappedStepFunction = () => this.executor.wrapStep(stepName, stepFunction);\n    return this.addStep(new LazyFunctionStep(stepName, wrappedStepFunction));\n  }\n  /**\n   * Stops the execution for the duration provided.\n   *\n   * @param stepName\n   * @param duration sleep duration in seconds\n   * @returns undefined\n   */\n  async sleep(stepName, duration) {\n    await this.addStep(new LazySleepStep(stepName, duration));\n  }\n  /**\n   * Stops the execution until the date time provided.\n   *\n   * @param stepName\n   * @param datetime time to sleep until. Can be provided as a number (in unix seconds),\n   *   as a Date object or a string (passed to `new Date(datetimeString)`)\n   * @returns undefined\n   */\n  async sleepUntil(stepName, datetime) {\n    let time;\n    if (typeof datetime === \"number\") {\n      time = datetime;\n    } else {\n      datetime = typeof datetime === \"string\" ? new Date(datetime) : datetime;\n      time = Math.round(datetime.getTime() / 1e3);\n    }\n    await this.addStep(new LazySleepUntilStep(stepName, time));\n  }\n  /**\n   * Makes a third party call through QStash in order to make a\n   * network call without consuming any runtime.\n   *\n   * ```ts\n   * const postResult = await context.call<string>(\n   *   \"post call step\",\n   *   `https://www.some-endpoint.com/api`,\n   *   \"POST\",\n   *   \"my-payload\"\n   * );\n   * ```\n   *\n   * tries to parse the result of the request as JSON. If it's\n   * not a JSON which can be parsed, simply returns the response\n   * body as it is.\n   *\n   * @param stepName\n   * @param url url to call\n   * @param method call method\n   * @param body call body\n   * @param headers call headers\n   * @returns call result (parsed as JSON if possible)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\n  async call(stepName, url, method, body, headers) {\n    const result = await this.addStep(\n      new LazyCallStep(stepName, url, method, body, headers ?? {})\n    );\n    try {\n      return JSON.parse(result);\n    } catch {\n      return result;\n    }\n  }\n  /**\n   * Adds steps to the executor. Needed so that it can be overwritten in\n   * DisabledWorkflowContext.\n   */\n  async addStep(step) {\n    return await this.executor.addStep(step);\n  }\n};\nvar DisabledWorkflowContext = class _DisabledWorkflowContext extends WorkflowContext {\n  static disabledMessage = \"disabled-qstash-worklfow-run\";\n  /**\n   * overwrite the WorkflowContext.addStep method to always raise QStashWorkflowAbort\n   * error in order to stop the execution whenever we encounter a step.\n   *\n   * @param _step\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async addStep(_step) {\n    throw new QStashWorkflowAbort(_DisabledWorkflowContext.disabledMessage);\n  }\n  /**\n   * copies the passed context to create a DisabledWorkflowContext. Then, runs the\n   * route function with the new context.\n   *\n   * - returns \"run-ended\" if there are no steps found or\n   *      if the auth failed and user called `return`\n   * - returns \"step-found\" if DisabledWorkflowContext.addStep is called.\n   * - if there is another error, returns the error.\n   *\n   * @param routeFunction\n   */\n  static async tryAuthentication(routeFunction, context) {\n    const disabledContext = new _DisabledWorkflowContext({\n      qstashClient: new Client({ baseUrl: \"disabled-client\", token: \"disabled-client\" }),\n      workflowRunId: context.workflowRunId,\n      headers: context.headers,\n      steps: [],\n      url: context.url,\n      failureUrl: context.failureUrl,\n      initialPayload: context.requestPayload,\n      rawInitialPayload: context.rawInitialPayload,\n      env: context.env,\n      retries: context.retries\n    });\n    try {\n      await routeFunction(disabledContext);\n    } catch (error) {\n      if (error instanceof QStashWorkflowAbort && error.stepName === this.disabledMessage) {\n        return ok2(\"step-found\");\n      }\n      return err2(error);\n    }\n    return ok2(\"run-ended\");\n  }\n};\n\n// src/client/workflow/logger.ts\nvar LOG_LEVELS = [\"DEBUG\", \"INFO\", \"SUBMIT\", \"WARN\", \"ERROR\"];\nvar WorkflowLogger = class _WorkflowLogger {\n  logs = [];\n  options;\n  workflowRunId = void 0;\n  constructor(options) {\n    this.options = options;\n  }\n  async log(level, eventType, details) {\n    if (this.shouldLog(level)) {\n      const timestamp = Date.now();\n      const logEntry = {\n        timestamp,\n        workflowRunId: this.workflowRunId ?? \"\",\n        logLevel: level,\n        eventType,\n        details\n      };\n      this.logs.push(logEntry);\n      if (this.options.logOutput === \"console\") {\n        this.writeToConsole(logEntry);\n      }\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n  }\n  setWorkflowRunId(workflowRunId) {\n    this.workflowRunId = workflowRunId;\n  }\n  writeToConsole(logEntry) {\n    const JSON_SPACING = 2;\n    console.log(JSON.stringify(logEntry, void 0, JSON_SPACING));\n  }\n  shouldLog(level) {\n    return LOG_LEVELS.indexOf(level) >= LOG_LEVELS.indexOf(this.options.logLevel);\n  }\n  static getLogger(verbose) {\n    if (typeof verbose === \"object\") {\n      return verbose;\n    } else {\n      return verbose ? new _WorkflowLogger({\n        logLevel: \"INFO\",\n        logOutput: \"console\"\n      }) : void 0;\n    }\n  }\n};\n\n// src/client/workflow/workflow-parser.ts\nimport { err as err3, ok as ok3 } from \"neverthrow\";\nvar getPayload = async (request) => {\n  try {\n    return await request.text();\n  } catch {\n    return;\n  }\n};\nvar parsePayload = (rawPayload) => {\n  const [encodedInitialPayload, ...encodedSteps] = JSON.parse(rawPayload);\n  const rawInitialPayload = decodeBase64(encodedInitialPayload.body);\n  const initialStep = {\n    stepId: 0,\n    stepName: \"init\",\n    stepType: \"Initial\",\n    out: rawInitialPayload,\n    concurrent: NO_CONCURRENCY\n  };\n  const stepsToDecode = encodedSteps.filter((step) => step.callType === \"step\");\n  const otherSteps = stepsToDecode.map((rawStep) => {\n    return JSON.parse(decodeBase64(rawStep.body));\n  });\n  const steps = [initialStep, ...otherSteps];\n  return {\n    rawInitialPayload,\n    steps\n  };\n};\nvar deduplicateSteps = (steps) => {\n  const targetStepIds = [];\n  const stepIds = [];\n  const deduplicatedSteps = [];\n  for (const step of steps) {\n    if (step.stepId === 0) {\n      if (!targetStepIds.includes(step.targetStep ?? 0)) {\n        deduplicatedSteps.push(step);\n        targetStepIds.push(step.targetStep ?? 0);\n      }\n    } else {\n      if (!stepIds.includes(step.stepId)) {\n        deduplicatedSteps.push(step);\n        stepIds.push(step.stepId);\n      }\n    }\n  }\n  return deduplicatedSteps;\n};\nvar checkIfLastOneIsDuplicate = async (steps, debug) => {\n  if (steps.length < 2) {\n    return false;\n  }\n  const lastStep = steps.at(-1);\n  const lastStepId = lastStep.stepId;\n  const lastTargetStepId = lastStep.targetStep;\n  for (let index = 0; index < steps.length - 1; index++) {\n    const step = steps[index];\n    if (step.stepId === lastStepId && step.targetStep === lastTargetStepId) {\n      const message = `Upstash Workflow: The step '${step.stepName}' with id '${step.stepId}'  has run twice during workflow execution. Rest of the workflow will continue running as usual.`;\n      await debug?.log(\"WARN\", \"RESPONSE_DEFAULT\", message);\n      console.warn(message);\n      return true;\n    }\n  }\n  return false;\n};\nvar validateRequest = (request) => {\n  const versionHeader = request.headers.get(WORKFLOW_PROTOCOL_VERSION_HEADER);\n  const isFirstInvocation = !versionHeader;\n  if (!isFirstInvocation && versionHeader !== WORKFLOW_PROTOCOL_VERSION) {\n    throw new QStashWorkflowError(\n      `Incompatible workflow sdk protocol version. Expected ${WORKFLOW_PROTOCOL_VERSION}, got ${versionHeader} from the request.`\n    );\n  }\n  const workflowRunId = isFirstInvocation ? `wfr_${nanoid()}` : request.headers.get(WORKFLOW_ID_HEADER) ?? \"\";\n  if (workflowRunId.length === 0) {\n    throw new QStashWorkflowError(\"Couldn't get workflow id from header\");\n  }\n  return {\n    isFirstInvocation,\n    workflowRunId\n  };\n};\nvar parseRequest = async (requestPayload, isFirstInvocation, debug) => {\n  if (isFirstInvocation) {\n    return {\n      rawInitialPayload: requestPayload ?? \"\",\n      steps: [],\n      isLastDuplicate: false\n    };\n  } else {\n    if (!requestPayload) {\n      throw new QStashWorkflowError(\"Only first call can have an empty body\");\n    }\n    const { rawInitialPayload, steps } = parsePayload(requestPayload);\n    const isLastDuplicate = await checkIfLastOneIsDuplicate(steps, debug);\n    const deduplicatedSteps = deduplicateSteps(steps);\n    return {\n      rawInitialPayload,\n      steps: deduplicatedSteps,\n      isLastDuplicate\n    };\n  }\n};\nvar handleFailure = async (request, requestPayload, qstashClient, initialPayloadParser, failureFunction, debug) => {\n  if (request.headers.get(WORKFLOW_FAILURE_HEADER) !== \"true\") {\n    return ok3(\"not-failure-callback\");\n  }\n  if (!failureFunction) {\n    return err3(\n      new QStashWorkflowError(\n        \"Workflow endpoint is called to handle a failure, but a failureFunction is not provided in serve options. Either provide a failureUrl or a failureFunction.\"\n      )\n    );\n  }\n  try {\n    const { status, header, body, url, sourceHeader, sourceBody, workflowRunId } = JSON.parse(\n      requestPayload\n    );\n    const decodedBody = body ? decodeBase64(body) : \"{}\";\n    const errorPayload = JSON.parse(decodedBody);\n    const {\n      rawInitialPayload,\n      steps,\n      isLastDuplicate: _isLastDuplicate\n    } = await parseRequest(decodeBase64(sourceBody), false, debug);\n    const workflowContext = new WorkflowContext({\n      qstashClient,\n      workflowRunId,\n      initialPayload: initialPayloadParser(rawInitialPayload),\n      rawInitialPayload,\n      headers: recreateUserHeaders(new Headers(sourceHeader)),\n      steps,\n      url,\n      failureUrl: url,\n      debug\n    });\n    await failureFunction(workflowContext, status, errorPayload.message, header);\n  } catch (error) {\n    return err3(error);\n  }\n  return ok3(\"is-failure-callback\");\n};\n\n// src/client/workflow/serve.ts\nvar processOptions = (options) => {\n  const environment = options?.env ?? (typeof process === \"undefined\" ? {} : process.env);\n  const receiverEnvironmentVariablesSet = Boolean(\n    environment.QSTASH_CURRENT_SIGNING_KEY && environment.QSTASH_NEXT_SIGNING_KEY\n  );\n  return {\n    qstashClient: new Client({\n      baseUrl: environment.QSTASH_URL,\n      token: environment.QSTASH_TOKEN\n    }),\n    onStepFinish: (workflowRunId, _finishCondition) => new Response(JSON.stringify({ workflowRunId }), {\n      status: 200\n    }),\n    initialPayloadParser: (initialRequest) => {\n      if (!initialRequest) {\n        return void 0;\n      }\n      try {\n        return JSON.parse(initialRequest);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          return initialRequest;\n        }\n        throw error;\n      }\n    },\n    receiver: receiverEnvironmentVariablesSet ? new Receiver({\n      currentSigningKey: environment.QSTASH_CURRENT_SIGNING_KEY,\n      nextSigningKey: environment.QSTASH_NEXT_SIGNING_KEY\n    }) : void 0,\n    baseUrl: environment.UPSTASH_WORKFLOW_URL,\n    env: environment,\n    retries: DEFAULT_RETRIES,\n    ...options\n  };\n};\nvar serve = (routeFunction, options) => {\n  const {\n    qstashClient,\n    onStepFinish,\n    initialPayloadParser,\n    url,\n    verbose,\n    receiver,\n    failureUrl,\n    failureFunction,\n    baseUrl,\n    env,\n    retries\n  } = processOptions(options);\n  const debug = WorkflowLogger.getLogger(verbose);\n  const handler = async (request) => {\n    const initialWorkflowUrl = url ?? request.url;\n    const workflowUrl = baseUrl ? initialWorkflowUrl.replace(/^(https?:\\/\\/[^/]+)(\\/.*)?$/, (_, matchedBaseUrl, path) => {\n      return baseUrl + (path || \"\");\n    }) : initialWorkflowUrl;\n    if (workflowUrl !== initialWorkflowUrl) {\n      await debug?.log(\"WARN\", \"ENDPOINT_START\", {\n        warning: `Upstash Workflow: replacing the base of the url with \"${baseUrl}\" and using it as workflow endpoint.`,\n        originalURL: initialWorkflowUrl,\n        updatedURL: workflowUrl\n      });\n    }\n    const workflowFailureUrl = failureFunction ? workflowUrl : failureUrl;\n    const requestPayload = await getPayload(request) ?? \"\";\n    await verifyRequest(requestPayload, request.headers.get(\"upstash-signature\"), receiver);\n    await debug?.log(\"INFO\", \"ENDPOINT_START\");\n    const failureCheck = await handleFailure(\n      request,\n      requestPayload,\n      qstashClient,\n      initialPayloadParser,\n      failureFunction\n    );\n    if (failureCheck.isErr()) {\n      throw failureCheck.error;\n    } else if (failureCheck.value === \"is-failure-callback\") {\n      await debug?.log(\"WARN\", \"RESPONSE_DEFAULT\", \"failureFunction executed\");\n      return onStepFinish(\"no-workflow-id\", \"failure-callback\");\n    }\n    const { isFirstInvocation, workflowRunId } = validateRequest(request);\n    debug?.setWorkflowRunId(workflowRunId);\n    const { rawInitialPayload, steps, isLastDuplicate } = await parseRequest(\n      requestPayload,\n      isFirstInvocation,\n      debug\n    );\n    if (isLastDuplicate) {\n      return onStepFinish(\"no-workflow-id\", \"duplicate-step\");\n    }\n    const workflowContext = new WorkflowContext({\n      qstashClient,\n      workflowRunId,\n      initialPayload: initialPayloadParser(rawInitialPayload),\n      rawInitialPayload,\n      headers: recreateUserHeaders(request.headers),\n      steps,\n      url: workflowUrl,\n      failureUrl: workflowFailureUrl,\n      debug,\n      env\n    });\n    const authCheck = await DisabledWorkflowContext.tryAuthentication(\n      routeFunction,\n      workflowContext\n    );\n    if (authCheck.isErr()) {\n      await debug?.log(\"ERROR\", \"ERROR\", { error: authCheck.error.message });\n      throw authCheck.error;\n    } else if (authCheck.value === \"run-ended\") {\n      return onStepFinish(\"no-workflow-id\", \"auth-fail\");\n    }\n    const callReturnCheck = await handleThirdPartyCallResult(\n      request,\n      rawInitialPayload,\n      qstashClient,\n      workflowUrl,\n      workflowFailureUrl,\n      retries,\n      debug\n    );\n    if (callReturnCheck.isErr()) {\n      await debug?.log(\"ERROR\", \"SUBMIT_THIRD_PARTY_RESULT\", {\n        error: callReturnCheck.error.message\n      });\n      throw callReturnCheck.error;\n    } else if (callReturnCheck.value === \"continue-workflow\") {\n      const result = isFirstInvocation ? await triggerFirstInvocation(workflowContext, retries, debug) : await triggerRouteFunction({\n        onStep: async () => routeFunction(workflowContext),\n        onCleanup: async () => {\n          await triggerWorkflowDelete(workflowContext, debug);\n        }\n      });\n      if (result.isErr()) {\n        await debug?.log(\"ERROR\", \"ERROR\", { error: result.error.message });\n        throw result.error;\n      }\n      await debug?.log(\"INFO\", \"RESPONSE_WORKFLOW\");\n      return onStepFinish(workflowContext.workflowRunId, \"success\");\n    }\n    await debug?.log(\"INFO\", \"RESPONSE_DEFAULT\");\n    return onStepFinish(\"no-workflow-id\", \"fromCallback\");\n  };\n  return async (request) => {\n    try {\n      return await handler(request);\n    } catch (error) {\n      console.error(error);\n      return new Response(JSON.stringify(formatWorkflowError(error)), { status: 500 });\n    }\n  };\n};\n\n// src/client/workflow/index.ts\nvar Workflow = class {\n  http;\n  constructor(http) {\n    this.http = http;\n  }\n  /**\n   * Cancel an ongoing workflow\n   *\n   * @param workflowRunId run id of the workflow to delete\n   * @returns true if workflow is succesfully deleted. Otherwise throws QStashError\n   */\n  async cancel(workflowRunId) {\n    const result = await this.http.request({\n      path: [\"v2\", \"workflows\", \"runs\", `${workflowRunId}?cancel=true`],\n      method: \"DELETE\",\n      parseResponseAsJson: false\n    });\n    return result ?? true;\n  }\n};\n\nexport {\n  SignatureError,\n  Receiver,\n  QstashError,\n  QstashRatelimitError,\n  QstashChatRatelimitError,\n  QstashDailyRatelimitError,\n  QStashWorkflowError,\n  QStashWorkflowAbort,\n  formatWorkflowError,\n  setupAnalytics,\n  Chat,\n  Messages,\n  BaseProvider,\n  upstash,\n  openai,\n  anthropic,\n  custom,\n  decodeBase64,\n  Schedules,\n  UrlGroups,\n  StepTypes,\n  WorkflowContext,\n  DisabledWorkflowContext,\n  WorkflowLogger,\n  processOptions,\n  serve,\n  Workflow,\n  Client\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2828, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Himaani/WebstormProjects/BibliaLMS/node_modules/%40upstash/qstash/chunk-4XJ4NO33.mjs"],"sourcesContent":["import {\n  BaseProvider\n} from \"./chunk-H3E2J2K6.mjs\";\n\n// src/client/api/email.ts\nvar EmailProvider = class extends BaseProvider {\n  apiKind = \"email\";\n  batch;\n  method = \"POST\";\n  constructor(baseUrl, token, owner, batch) {\n    super(baseUrl, token, owner);\n    this.batch = batch;\n  }\n  getRoute() {\n    return this.batch ? [\"emails\", \"batch\"] : [\"emails\"];\n  }\n  getHeaders(_options) {\n    return {\n      authorization: `Bearer ${this.token}`\n    };\n  }\n  onFinish(providerInfo, _options) {\n    return providerInfo;\n  }\n};\nvar resend = ({\n  token,\n  batch = false\n}) => {\n  return new EmailProvider(\"https://api.resend.com\", token, \"resend\", batch);\n};\n\nexport {\n  resend\n};\n"],"names":[],"mappings":";;;AAAA;;AAIA,0BAA0B;AAC1B,IAAI,gBAAgB,cAAc,yJAAA,CAAA,eAAY;IAC5C,UAAU,QAAQ;IAClB,MAAM;IACN,SAAS,OAAO;IAChB,YAAY,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAE;QACxC,KAAK,CAAC,SAAS,OAAO;QACtB,IAAI,CAAC,KAAK,GAAG;IACf;IACA,WAAW;QACT,OAAO,IAAI,CAAC,KAAK,GAAG;YAAC;YAAU;SAAQ,GAAG;YAAC;SAAS;IACtD;IACA,WAAW,QAAQ,EAAE;QACnB,OAAO;YACL,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE;QACvC;IACF;IACA,SAAS,YAAY,EAAE,QAAQ,EAAE;QAC/B,OAAO;IACT;AACF;AACA,IAAI,SAAS,CAAC,EACZ,KAAK,EACL,QAAQ,KAAK,EACd;IACC,OAAO,IAAI,cAAc,0BAA0B,OAAO,UAAU;AACtE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2867, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Himaani/WebstormProjects/BibliaLMS/node_modules/%40upstash/qstash/index.mjs"],"sourcesContent":["import {\n  resend\n} from \"./chunk-4XJ4NO33.mjs\";\nimport {\n  Chat,\n  Client,\n  Messages,\n  QStashWorkflowAbort,\n  QStashWorkflowError,\n  QstashChatRatelimitError,\n  QstashDailyRatelimitError,\n  QstashError,\n  QstashRatelimitError,\n  Receiver,\n  Schedules,\n  SignatureError,\n  UrlGroups,\n  anthropic,\n  custom,\n  decodeBase64,\n  formatWorkflowError,\n  openai,\n  setupAnalytics,\n  upstash\n} from \"./chunk-H3E2J2K6.mjs\";\nexport {\n  Chat,\n  Client,\n  Messages,\n  QStashWorkflowAbort,\n  QStashWorkflowError,\n  QstashChatRatelimitError,\n  QstashDailyRatelimitError,\n  QstashError,\n  QstashRatelimitError,\n  Receiver,\n  Schedules,\n  SignatureError,\n  UrlGroups,\n  anthropic,\n  custom,\n  decodeBase64,\n  formatWorkflowError,\n  openai,\n  resend,\n  setupAnalytics,\n  upstash\n};\n"],"names":[],"mappings":";AAAA;AAGA","ignoreList":[0],"debugId":null}}]
}